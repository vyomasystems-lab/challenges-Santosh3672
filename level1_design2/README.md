# Buggy Sequence Detector
### To test the buggy sequence detector we first provided following manual sequence 1011011, to check if overlapping property is working or not. 
![](https://github.com/vyomasystems-lab/challenges-Santosh3672/blob/master/level1_design2/Pic1.JPG)
### Above we can see the the overlapping feature seems buggy. As the output is 1 for the first 1011 sequence seen but in the next sequence which overlappend with previous sequence it doesnt recognize that. On checking the design code in line 69 we see that when current state is final state of FSM (SEQ_1011), the next state is IDLE state.
### Which would make it a non overlapping sequence detector but for a overlapping sequence detector it should be equivalent to state of SEQ_1(last 1 of 1011 can be used to form another new state). After fixing this bug in last state SEQ_1011 lets verify it again, now all the patterns inserted are random numbers generated by pyhon.
![](https://github.com/vyomasystems-lab/challenges-Santosh3672/blob/master/level1_design2/Pic2.JPG)
### We are getting value 0 when a sequence of 1011 is detected. Lets verify it from the last time we observed 1 because from that we can know about the internal state of FSM which is SEQ_1011.
### Inputs after last time output was 1(at 85000 ns) are 1011, the states of the FSM after each input as per model and as per buggy design are tables below.

| Input: | Model State: | Buggy Design State: |
|--------|--------------|---------------------|
| 1      | SEQ_1011     | SEQ_1011            |
| 1      | SEQ_1        | IDLE                |
| 0      | SEQ_10       | IDLE                |
| 1      | SEQ_101      | SEQ_1               |
| 1      | SEQ_1011     | SEQ_1               |

### Here we see that when current state is SEQ_1011 or SEQ_1 which we hace proved are equivalent for non overlapping detector when input is 1 the next state should be SEQ_1 while it is going to IDLE for buggy design. Because we have just copied the next state code from SEQ_1 to SEQ_1011 both these states needs to be rectified.
### After rectifying this bug lets verify again.
![](https://github.com/vyomasystems-lab/challenges-Santosh3672/blob/master/level1_design2/Pic3.JPG)
### Again lets follow previous strategy to Debug the cause of error by comparing MODEL states and Buggy design states. We will start from time 475000 ns where output was 1 hence state was known to us i.e. SEQ_1011.

| Input | Model State | Bugy Design State |
|-------|-------------|-------------------|
| 1     | SEQ_1011    | SEQ_1011          |
| 1     | SEQ_1       | SEQ_1             |
| 1     | SEQ_1       | SEQ_1             |
| 1     | SEQ_1       | SEQ_1             |
| 0     | SEQ_10      | SEQ_10            |
| 0     | IDLE        | IDLE              |
| 1     | SEQ_1       | SEQ_1             |
| 0     | SEQ_10      | SEQ_10            |
| 0     | IDLE        | IDLE              |
| 1     | SEQ_1       | SEQ_1             |
| 1     | SEQ_1       | SEQ_1             |
| 0     | SEQ_10      | SEQ_10            |
| 1     | SEQ_101     | SEQ_101           |
| 0     | SEQ_10      | IDLE              |
| 1     | SEQ_101     | SEQ_1             |
| 1     | SEQ_1011    | SEQ_1             |

### From above table we can see differences coming after state SEQ_101 when output is 0 while current state is SEQ_101, next state should be SEQ_10, but it is IDLE in buggy design, let's rectify it and verify again.
### There are no additional bugs found we tried to run it for 5000 iterations. Next we tested if the reset key worked properly or not in another test called test_seq_bug_reset_check. As shown below the reset logic is also working as expected.
![](https://github.com/vyomasystems-lab/challenges-Santosh3672/blob/master/level1_design2/Pic4.JPG)
